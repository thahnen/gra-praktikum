<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Royale: royale::basicString&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="royale-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Royale
   </div>
   <div id="projectbrief">powerful software framework for time-of-flight cameras</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceroyale.html">royale</a></li><li class="navelem"><a class="el" href="classroyale_1_1basic_string.html">basicString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classroyale_1_1basic_string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">royale::basicString&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_string_8hpp_source.html">String.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a23f69382a3f5949725fa552b58ae29ef"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classroyale_1_1iterator_1_1royale__iterator.html">royale::iterator::royale_iterator</a><br class="typebreak"/>
&lt; std::random_access_iterator_tag, <br class="typebreak"/>
T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a></td></tr>
<tr class="memdesc:a23f69382a3f5949725fa552b58ae29ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator definitions.  <a href="#a23f69382a3f5949725fa552b58ae29ef">More...</a><br/></td></tr>
<tr class="separator:a23f69382a3f5949725fa552b58ae29ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab114ad5253c9066fb12a30b68a2bc132"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classroyale_1_1iterator_1_1royale__const__iterator.html">royale::iterator::royale_const_iterator</a><br class="typebreak"/>
&lt; std::random_access_iterator_tag, <br class="typebreak"/>
T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a></td></tr>
<tr class="separator:ab114ad5253c9066fb12a30b68a2bc132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98bf79c04dc2a790a5e36373e045121"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classroyale_1_1iterator_1_1royale__reverse__iterator.html">royale::iterator::royale_reverse_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ae98bf79c04dc2a790a5e36373e045121">reverse_iterator</a></td></tr>
<tr class="separator:ae98bf79c04dc2a790a5e36373e045121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97b056944f5e5c0a37c54947308c78"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classroyale_1_1iterator_1_1royale__const__reverse__iterator.html">royale::iterator::royale_const_reverse_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a></td></tr>
<tr class="separator:a1b97b056944f5e5c0a37c54947308c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf6a582542b8cdc384b0eee904679e"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a></td></tr>
<tr class="memdesc:a8faf6a582542b8cdc384b0eee904679e"><td class="mdescLeft">&#160;</td><td class="mdescRight">General String definitions.  <a href="#a8faf6a582542b8cdc384b0eee904679e">More...</a><br/></td></tr>
<tr class="separator:a8faf6a582542b8cdc384b0eee904679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26b6f53a1c7fe05800f3124824c8344"><td class="memItemLeft" align="right" valign="top">typedef std::char_traits&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ae26b6f53a1c7fe05800f3124824c8344">traits_type</a></td></tr>
<tr class="separator:ae26b6f53a1c7fe05800f3124824c8344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d539cda1422c12a7dfa80f82020dfb8"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a5d539cda1422c12a7dfa80f82020dfb8">reference</a></td></tr>
<tr class="separator:a5d539cda1422c12a7dfa80f82020dfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d5f3e7b20ea82ebb63a7dd0a851c3f"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a51d5f3e7b20ea82ebb63a7dd0a851c3f">const_reference</a></td></tr>
<tr class="separator:a51d5f3e7b20ea82ebb63a7dd0a851c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920a63d18280f2a62110199a80912822"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a920a63d18280f2a62110199a80912822">pointer</a></td></tr>
<tr class="separator:a920a63d18280f2a62110199a80912822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bb5737c3b41f8cd97da3dbfdaef4b0"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a99bb5737c3b41f8cd97da3dbfdaef4b0">const_pointer</a></td></tr>
<tr class="separator:a99bb5737c3b41f8cd97da3dbfdaef4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e483d21c3e48468b5cf686a15be1ad"><td class="memItemLeft" align="right" valign="top">typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ac9e483d21c3e48468b5cf686a15be1ad">difference_type</a></td></tr>
<tr class="separator:ac9e483d21c3e48468b5cf686a15be1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114882b7ee678c295e29f66972950f4d"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a114882b7ee678c295e29f66972950f4d">size_type</a></td></tr>
<tr class="separator:a114882b7ee678c295e29f66972950f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a849cb5c82de63707e558bab9996f8ef9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a849cb5c82de63707e558bab9996f8ef9">basicString</a> ()</td></tr>
<tr class="memdesc:a849cb5c82de63707e558bab9996f8ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a849cb5c82de63707e558bab9996f8ef9">More...</a><br/></td></tr>
<tr class="separator:a849cb5c82de63707e558bab9996f8ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16c536bb88c352db8a89039d4b1ec64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa16c536bb88c352db8a89039d4b1ec64">basicString</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:aa16c536bb88c352db8a89039d4b1ec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-Constructor for royale compliant string.  <a href="#aa16c536bb88c352db8a89039d4b1ec64">More...</a><br/></td></tr>
<tr class="separator:aa16c536bb88c352db8a89039d4b1ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56594a8cd85bd045aef2d0e3f9d091b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a56594a8cd85bd045aef2d0e3f9d091b8">basicString</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:a56594a8cd85bd045aef2d0e3f9d091b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-Constructor for STL compliant string (std::string)  <a href="#a56594a8cd85bd045aef2d0e3f9d091b8">More...</a><br/></td></tr>
<tr class="separator:a56594a8cd85bd045aef2d0e3f9d091b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07d1648687b09e263059886b174cbdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab07d1648687b09e263059886b174cbdd">basicString</a> (<a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:ab07d1648687b09e263059886b174cbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-Constructor for royale compliant string.  <a href="#ab07d1648687b09e263059886b174cbdd">More...</a><br/></td></tr>
<tr class="separator:ab07d1648687b09e263059886b174cbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d9bed011982b11084913f2c69f7fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a095d9bed011982b11084913f2c69f7fa">basicString</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str, size_t pos, size_t len=<a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a>)</td></tr>
<tr class="memdesc:a095d9bed011982b11084913f2c69f7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows passing a royale compliant string and add it at a given position - the caller might also limit the length that shall be copied (NOTE: performs a deep copy!)  <a href="#a095d9bed011982b11084913f2c69f7fa">More...</a><br/></td></tr>
<tr class="separator:a095d9bed011982b11084913f2c69f7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ebe53d7353e3491ebc116643c467a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a11ebe53d7353e3491ebc116643c467a8">basicString</a> (const std::basic_string&lt; T &gt; &amp;str, size_t pos, size_t len=<a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a>)</td></tr>
<tr class="memdesc:a11ebe53d7353e3491ebc116643c467a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows passing a STL compliant string and add it at a given position - the caller might also limit the length that shall be copied (NOTE: performs a deep copy!)  <a href="#a11ebe53d7353e3491ebc116643c467a8">More...</a><br/></td></tr>
<tr class="separator:a11ebe53d7353e3491ebc116643c467a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060d202e53cf9ae966a13c44df197a5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a060d202e53cf9ae966a13c44df197a5c">basicString</a> (const T *s)</td></tr>
<tr class="memdesc:a060d202e53cf9ae966a13c44df197a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows passing a C-Style string to create a royale compliant string (NOTE: performs a deep copy!)  <a href="#a060d202e53cf9ae966a13c44df197a5c">More...</a><br/></td></tr>
<tr class="separator:a060d202e53cf9ae966a13c44df197a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b071b29fec507d5f6484bff0653cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a295b071b29fec507d5f6484bff0653cd">basicString</a> (const T *s, size_t n)</td></tr>
<tr class="memdesc:a295b071b29fec507d5f6484bff0653cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows passing a C-Style string to create a royale compliant string by copying the first n bytes (NOTE: performs a deep copy!)  <a href="#a295b071b29fec507d5f6484bff0653cd">More...</a><br/></td></tr>
<tr class="separator:a295b071b29fec507d5f6484bff0653cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c39fec67ca9c71be71ac3b7c79cc8e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a2c39fec67ca9c71be71ac3b7c79cc8e3">basicString</a> (size_t n, T c)</td></tr>
<tr class="memdesc:a2c39fec67ca9c71be71ac3b7c79cc8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows creating a royale compliant string with n slots which are initialized by character c.  <a href="#a2c39fec67ca9c71be71ac3b7c79cc8e3">More...</a><br/></td></tr>
<tr class="separator:a2c39fec67ca9c71be71ac3b7c79cc8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0783454d063ac865be29c630a23bbe57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0783454d063ac865be29c630a23bbe57">basicString</a> (const std::initializer_list&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:a0783454d063ac865be29c630a23bbe57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list initialization to initialize a string.  <a href="#a0783454d063ac865be29c630a23bbe57">More...</a><br/></td></tr>
<tr class="separator:a0783454d063ac865be29c630a23bbe57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334aade8c84f9ea903687ab4a0a6ec9e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a334aade8c84f9ea903687ab4a0a6ec9e">~basicString</a> ()</td></tr>
<tr class="memdesc:a334aade8c84f9ea903687ab4a0a6ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a334aade8c84f9ea903687ab4a0a6ec9e">More...</a><br/></td></tr>
<tr class="separator:a334aade8c84f9ea903687ab4a0a6ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48df31da4d8c5f4b82cb62113834dc3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3">size</a> () const </td></tr>
<tr class="memdesc:ad48df31da4d8c5f4b82cb62113834dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size/length of the string (this is the used amount of slots in the allocated area)  <a href="#ad48df31da4d8c5f4b82cb62113834dc3">More...</a><br/></td></tr>
<tr class="separator:ad48df31da4d8c5f4b82cb62113834dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af809776b19cba7a749809095208e0aeb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af809776b19cba7a749809095208e0aeb">length</a> () const </td></tr>
<tr class="memdesc:af809776b19cba7a749809095208e0aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size/length of the string (this is the used amount of slots in the allocated area)  <a href="#af809776b19cba7a749809095208e0aeb">More...</a><br/></td></tr>
<tr class="separator:af809776b19cba7a749809095208e0aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c32ccae743c4e5be4503a73e668921"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a61c32ccae743c4e5be4503a73e668921">empty</a> () const </td></tr>
<tr class="memdesc:a61c32ccae743c4e5be4503a73e668921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the string is empty.  <a href="#a61c32ccae743c4e5be4503a73e668921">More...</a><br/></td></tr>
<tr class="separator:a61c32ccae743c4e5be4503a73e668921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a7db4b08f705cfc1a6a7a28d41f76e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab0a7db4b08f705cfc1a6a7a28d41f76e">capacity</a> () const </td></tr>
<tr class="memdesc:ab0a7db4b08f705cfc1a6a7a28d41f76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of allocated slots which are maintained by the vector These allocated slots might be used or unused (refer to <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3" title="Returns the actual size/length of the string (this is the used amount of slots in the allocated area)...">size()</a> for checking the <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3" title="Returns the actual size/length of the string (this is the used amount of slots in the allocated area)...">size()</a> itself) The implicitly added NUL termination is not counted as part of the capacity.  <a href="#ab0a7db4b08f705cfc1a6a7a28d41f76e">More...</a><br/></td></tr>
<tr class="separator:ab0a7db4b08f705cfc1a6a7a28d41f76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9354acd2c34f8a317da08a3d51f3627"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ae9354acd2c34f8a317da08a3d51f3627">data</a> () const </td></tr>
<tr class="memdesc:ae9354acd2c34f8a317da08a3d51f3627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direct pointer to the memory array used internally by the string to store its owned elements.  <a href="#ae9354acd2c34f8a317da08a3d51f3627">More...</a><br/></td></tr>
<tr class="separator:ae9354acd2c34f8a317da08a3d51f3627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb106ac4582f9b2714401e6d5faf070"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8cb106ac4582f9b2714401e6d5faf070">front</a> ()</td></tr>
<tr class="memdesc:a8cb106ac4582f9b2714401e6d5faf070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the string.  <a href="#a8cb106ac4582f9b2714401e6d5faf070">More...</a><br/></td></tr>
<tr class="separator:a8cb106ac4582f9b2714401e6d5faf070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b29e24293dbe4132c8ce6f188536d51"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0b29e24293dbe4132c8ce6f188536d51">front</a> () const </td></tr>
<tr class="separator:a0b29e24293dbe4132c8ce6f188536d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e03cf2945f5219883ce3a40940b9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a27e03cf2945f5219883ce3a40940b9bf">begin</a> ()</td></tr>
<tr class="memdesc:a27e03cf2945f5219883ce3a40940b9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first position Calling this function on an empty string will result in undefined behavior.  <a href="#a27e03cf2945f5219883ce3a40940b9bf">More...</a><br/></td></tr>
<tr class="separator:a27e03cf2945f5219883ce3a40940b9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cb764f7500123b619ba6881243092c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a98cb764f7500123b619ba6881243092c">begin</a> () const </td></tr>
<tr class="separator:a98cb764f7500123b619ba6881243092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720a9923d1c9b04ed5f2ad0e1019a6b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a720a9923d1c9b04ed5f2ad0e1019a6b8">end</a> ()</td></tr>
<tr class="memdesc:a720a9923d1c9b04ed5f2ad0e1019a6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the last position Calling this function on an empty string will result in undefined behavior.  <a href="#a720a9923d1c9b04ed5f2ad0e1019a6b8">More...</a><br/></td></tr>
<tr class="separator:a720a9923d1c9b04ed5f2ad0e1019a6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac142c88f4c79c3dafd315a052210c92e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ac142c88f4c79c3dafd315a052210c92e">end</a> () const </td></tr>
<tr class="separator:ac142c88f4c79c3dafd315a052210c92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4549c6bd0e0ab7d02e2271e577dd9c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ae98bf79c04dc2a790a5e36373e045121">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ae4549c6bd0e0ab7d02e2271e577dd9c8">rbegin</a> ()</td></tr>
<tr class="memdesc:ae4549c6bd0e0ab7d02e2271e577dd9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse begin (last position) Calling this function on an empty string will result in undefined behavior.  <a href="#ae4549c6bd0e0ab7d02e2271e577dd9c8">More...</a><br/></td></tr>
<tr class="separator:ae4549c6bd0e0ab7d02e2271e577dd9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab932d087ac23672cbe3b1af26d2aff6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab932d087ac23672cbe3b1af26d2aff6d">rbegin</a> () const </td></tr>
<tr class="separator:ab932d087ac23672cbe3b1af26d2aff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5357e6b130c3675d3d1918a5277c8521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ae98bf79c04dc2a790a5e36373e045121">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a5357e6b130c3675d3d1918a5277c8521">rend</a> ()</td></tr>
<tr class="memdesc:a5357e6b130c3675d3d1918a5277c8521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse end (first position) Calling this function on an empty string will result in undefined behavior.  <a href="#a5357e6b130c3675d3d1918a5277c8521">More...</a><br/></td></tr>
<tr class="separator:a5357e6b130c3675d3d1918a5277c8521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf4748d31fecad8a6abf93cdbc83f99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#addf4748d31fecad8a6abf93cdbc83f99">rend</a> () const </td></tr>
<tr class="separator:addf4748d31fecad8a6abf93cdbc83f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b0fb6f48077ea64ff5327c3911836e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa2b0fb6f48077ea64ff5327c3911836e">cbegin</a> ()</td></tr>
<tr class="memdesc:aa2b0fb6f48077ea64ff5327c3911836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the begin of the string (first position) Calling this function on an empty string will result in undefined behavior.  <a href="#aa2b0fb6f48077ea64ff5327c3911836e">More...</a><br/></td></tr>
<tr class="separator:aa2b0fb6f48077ea64ff5327c3911836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ed31b25b1278756b1c3f75d3750482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a62ed31b25b1278756b1c3f75d3750482">cbegin</a> () const </td></tr>
<tr class="separator:a62ed31b25b1278756b1c3f75d3750482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6312883cb35f8a8bb219b79f64ff043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad6312883cb35f8a8bb219b79f64ff043">cend</a> ()</td></tr>
<tr class="memdesc:ad6312883cb35f8a8bb219b79f64ff043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end of the string (last position) Calling this function on an empty string will result in undefined behavior.  <a href="#ad6312883cb35f8a8bb219b79f64ff043">More...</a><br/></td></tr>
<tr class="separator:ad6312883cb35f8a8bb219b79f64ff043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51088e9351dcaa4cab77989cc720aae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a51088e9351dcaa4cab77989cc720aae0">cend</a> () const </td></tr>
<tr class="separator:a51088e9351dcaa4cab77989cc720aae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a8716f95080111dca7abe88eb4db58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a70a8716f95080111dca7abe88eb4db58">crbegin</a> ()</td></tr>
<tr class="memdesc:a70a8716f95080111dca7abe88eb4db58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the reverse begin of the string (last position) Calling this function on an empty string will result in undefined behavior.  <a href="#a70a8716f95080111dca7abe88eb4db58">More...</a><br/></td></tr>
<tr class="separator:a70a8716f95080111dca7abe88eb4db58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf1ab1304690abceec8b1c3a3f44956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aebf1ab1304690abceec8b1c3a3f44956">crbegin</a> () const </td></tr>
<tr class="separator:aebf1ab1304690abceec8b1c3a3f44956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205596ff77fbc7297e2b8d1f34deadae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a205596ff77fbc7297e2b8d1f34deadae">crend</a> ()</td></tr>
<tr class="memdesc:a205596ff77fbc7297e2b8d1f34deadae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the reverse end of the string (first position) Calling this function on an empty string will result in undefined behavior.  <a href="#a205596ff77fbc7297e2b8d1f34deadae">More...</a><br/></td></tr>
<tr class="separator:a205596ff77fbc7297e2b8d1f34deadae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629f982fe719d3b59f8b682c4a7ab188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a629f982fe719d3b59f8b682c4a7ab188">crend</a> () const </td></tr>
<tr class="separator:a629f982fe719d3b59f8b682c4a7ab188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7de3a704276aa4929205ce5bc944a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a5f7de3a704276aa4929205ce5bc944a5">iteratorFromIndex</a> (size_t index)</td></tr>
<tr class="memdesc:a5f7de3a704276aa4929205ce5bc944a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an forward iterator for the given index.  <a href="#a5f7de3a704276aa4929205ce5bc944a5">More...</a><br/></td></tr>
<tr class="separator:a5f7de3a704276aa4929205ce5bc944a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783d41ec1e99ea73bd3458cddc5ba962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a783d41ec1e99ea73bd3458cddc5ba962">iteratorFromIndex</a> (size_t index) const </td></tr>
<tr class="separator:a783d41ec1e99ea73bd3458cddc5ba962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3e9dcf9a252536d0cce17ee9b2cf80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#ae98bf79c04dc2a790a5e36373e045121">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8e3e9dcf9a252536d0cce17ee9b2cf80">reverseIteratorFromIndex</a> (size_t index)</td></tr>
<tr class="memdesc:a8e3e9dcf9a252536d0cce17ee9b2cf80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an reverse iterator for the given index.  <a href="#a8e3e9dcf9a252536d0cce17ee9b2cf80">More...</a><br/></td></tr>
<tr class="separator:a8e3e9dcf9a252536d0cce17ee9b2cf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d427ddd26eab3994d16e61fb6f5636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a61d427ddd26eab3994d16e61fb6f5636">reverseIteratorFromIndex</a> (size_t index) const </td></tr>
<tr class="separator:a61d427ddd26eab3994d16e61fb6f5636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274990baf201866f1e4840c7abe3104a"><td class="memTemplParams" colspan="2">template&lt;typename... Dummy, typename IteratorType , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;IteratorType, reverse_iterator&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:a274990baf201866f1e4840c7abe3104a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a274990baf201866f1e4840c7abe3104a">indexFromIterator</a> (IteratorType it)</td></tr>
<tr class="memdesc:a274990baf201866f1e4840c7abe3104a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index position the given iterator is pointing to One may receive weird results by passing an iterator of another vector object! Take care that only indices from the current vector object are passed!  <a href="#a274990baf201866f1e4840c7abe3104a">More...</a><br/></td></tr>
<tr class="separator:a274990baf201866f1e4840c7abe3104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12795ad1f341d42da6833c4b9bc9a22f"><td class="memTemplParams" colspan="2">template&lt;typename... Dummy, typename IteratorType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;IteratorType, reverse_iterator&gt;::value || royale::iterator::is_same&lt;IteratorType, const_reverse_iterator&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:a12795ad1f341d42da6833c4b9bc9a22f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a12795ad1f341d42da6833c4b9bc9a22f">indexFromIterator</a> (IteratorType it) const </td></tr>
<tr class="separator:a12795ad1f341d42da6833c4b9bc9a22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11f7ca0dd18490a72dc59ddf8235281"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;IteratorType, iterator&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:af11f7ca0dd18490a72dc59ddf8235281"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af11f7ca0dd18490a72dc59ddf8235281">indexFromIterator</a> (IteratorType it)</td></tr>
<tr class="memdesc:af11f7ca0dd18490a72dc59ddf8235281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index position the given iterator is pointing to One may receive weird results by passing an iterator of another vector object! Take care that only indices from the current vector object are passed!  <a href="#af11f7ca0dd18490a72dc59ddf8235281">More...</a><br/></td></tr>
<tr class="separator:af11f7ca0dd18490a72dc59ddf8235281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6793a07e15fffc1aca8467b6a01f247c"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;IteratorType, iterator&gt;::value || royale::iterator::is_same&lt;IteratorType, const_iterator&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:a6793a07e15fffc1aca8467b6a01f247c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6793a07e15fffc1aca8467b6a01f247c">indexFromIterator</a> (IteratorType it) const </td></tr>
<tr class="separator:a6793a07e15fffc1aca8467b6a01f247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d27ea55b0638d7d3cf451a8eeba4c7"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a64d27ea55b0638d7d3cf451a8eeba4c7">back</a> ()</td></tr>
<tr class="memdesc:a64d27ea55b0638d7d3cf451a8eeba4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the string.  <a href="#a64d27ea55b0638d7d3cf451a8eeba4c7">More...</a><br/></td></tr>
<tr class="separator:a64d27ea55b0638d7d3cf451a8eeba4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6e825f914dce79aacefded90b3bfa3"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a3f6e825f914dce79aacefded90b3bfa3">back</a> () const </td></tr>
<tr class="separator:a3f6e825f914dce79aacefded90b3bfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff17794f88e1107b3a2e89e2bf0afde6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aff17794f88e1107b3a2e89e2bf0afde6">push_back</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:aff17794f88e1107b3a2e89e2bf0afde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the string, after its current last element.  <a href="#aff17794f88e1107b3a2e89e2bf0afde6">More...</a><br/></td></tr>
<tr class="separator:aff17794f88e1107b3a2e89e2bf0afde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7033616dddc037749c3cb6a8935fc88d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7033616dddc037749c3cb6a8935fc88d">push_back</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="separator:a7033616dddc037749c3cb6a8935fc88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3009df262d03ec25bb308501c65f824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab3009df262d03ec25bb308501c65f824">push_back</a> (const std::basic_string&lt; T &gt; &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:ab3009df262d03ec25bb308501c65f824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ed47847028e76ad19810cbe8dcfe2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a50ed47847028e76ad19810cbe8dcfe2d">push_back</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:a50ed47847028e76ad19810cbe8dcfe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc2dca452a65908b63266f21f4b29de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#addc2dca452a65908b63266f21f4b29de">push_back</a> (const T *str)</td></tr>
<tr class="separator:addc2dca452a65908b63266f21f4b29de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18d78393183efce70780049078379a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9c18d78393183efce70780049078379a">push_back</a> (const T *str, size_t n)</td></tr>
<tr class="separator:a9c18d78393183efce70780049078379a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ed99a88bf1c232068b4dc8ae6d413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6b5ed99a88bf1c232068b4dc8ae6d413">push_back</a> (size_t n, T c)</td></tr>
<tr class="separator:a6b5ed99a88bf1c232068b4dc8ae6d413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3a81a50aa0d0f3055caf3bc2d6de93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ace3a81a50aa0d0f3055caf3bc2d6de93">push_back</a> (const T c)</td></tr>
<tr class="separator:ace3a81a50aa0d0f3055caf3bc2d6de93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08c6fb824a972346fff20ea92794331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af08c6fb824a972346fff20ea92794331">append</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:af08c6fb824a972346fff20ea92794331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the string, after its current last element and returns the actual string element.  <a href="#af08c6fb824a972346fff20ea92794331">More...</a><br/></td></tr>
<tr class="separator:af08c6fb824a972346fff20ea92794331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8232e4e559b251e4d304b9e520d7643e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8232e4e559b251e4d304b9e520d7643e">append</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="separator:a8232e4e559b251e4d304b9e520d7643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc7fbaabcaa7911379e33a23f044ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#adcc7fbaabcaa7911379e33a23f044ea7">append</a> (const std::basic_string&lt; T &gt; &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:adcc7fbaabcaa7911379e33a23f044ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f4ac053c4b73faf7c71fde481e4387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a71f4ac053c4b73faf7c71fde481e4387">append</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:a71f4ac053c4b73faf7c71fde481e4387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cc3ed778fbb661776391595993e119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a38cc3ed778fbb661776391595993e119">append</a> (const T *str)</td></tr>
<tr class="separator:a38cc3ed778fbb661776391595993e119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024faa49d8010fbcb0372d25a284c91f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a024faa49d8010fbcb0372d25a284c91f">append</a> (const T *str, size_t n)</td></tr>
<tr class="separator:a024faa49d8010fbcb0372d25a284c91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad153702cf2e8d04d728dbd62ab659940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad153702cf2e8d04d728dbd62ab659940">append</a> (size_t n, T c)</td></tr>
<tr class="separator:ad153702cf2e8d04d728dbd62ab659940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae2cfa6e7f521e2a63a0aedd3b46375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aeae2cfa6e7f521e2a63a0aedd3b46375">append</a> (const T c)</td></tr>
<tr class="separator:aeae2cfa6e7f521e2a63a0aedd3b46375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5adfabbcfaa4dc8f33ece4bb424287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a5f5adfabbcfaa4dc8f33ece4bb424287">operator+=</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:a5f5adfabbcfaa4dc8f33ece4bb424287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the string, after its current last element and returns the actual string element.  <a href="#a5f5adfabbcfaa4dc8f33ece4bb424287">More...</a><br/></td></tr>
<tr class="separator:a5f5adfabbcfaa4dc8f33ece4bb424287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6d96f0b1ad3a1c28ab61ce6f52919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a51c6d96f0b1ad3a1c28ab61ce6f52919">operator+=</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="separator:a51c6d96f0b1ad3a1c28ab61ce6f52919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76856ac5023d9a1d437607a74034ff00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a76856ac5023d9a1d437607a74034ff00">operator+=</a> (const T *s)</td></tr>
<tr class="separator:a76856ac5023d9a1d437607a74034ff00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff8a7c5d2a0cfc6434221b818c5fd01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9ff8a7c5d2a0cfc6434221b818c5fd01">operator+=</a> (const T s)</td></tr>
<tr class="separator:a9ff8a7c5d2a0cfc6434221b818c5fd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db1a86f363b6c6b9267352a9638e192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6db1a86f363b6c6b9267352a9638e192">operator+</a> (const std::basic_string&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a6db1a86f363b6c6b9267352a9638e192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two stirngs and returns the result (the second string is appended) The content of str is copied to the newly created element (NOTE: a deep copy is performed!).  <a href="#a6db1a86f363b6c6b9267352a9638e192">More...</a><br/></td></tr>
<tr class="separator:a6db1a86f363b6c6b9267352a9638e192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8526b68e24a8c7bc514288ef20030441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8526b68e24a8c7bc514288ef20030441">operator+</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="separator:a8526b68e24a8c7bc514288ef20030441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0bc4697cf123ff2c93ab3ae368e31c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6b0bc4697cf123ff2c93ab3ae368e31c">operator+</a> (const T *s) const </td></tr>
<tr class="separator:a6b0bc4697cf123ff2c93ab3ae368e31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40315b22baee696456acf7baa75643a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a40315b22baee696456acf7baa75643a7">operator+</a> (const T s) const </td></tr>
<tr class="separator:a40315b22baee696456acf7baa75643a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b35bd43d108b5aa853698f8d742857"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;StringType, basicString&lt;T&gt;&gt;::value || royale::iterator::is_same&lt;StringType, std::string&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:ab0b35bd43d108b5aa853698f8d742857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab0b35bd43d108b5aa853698f8d742857">insert</a> (size_t pos, const StringType &amp;str)</td></tr>
<tr class="memdesc:ab0b35bd43d108b5aa853698f8d742857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements to the string The content at the given position is moved backwards in the string to create space for the elements which shall be inserted - given there is enough allocated space If the allocation is too small to insert the bunch of data, a new block is allocated, while the old data is MOVED (std::move) to the new buffer as long as the insert position is not reached.  <a href="#ab0b35bd43d108b5aa853698f8d742857">More...</a><br/></td></tr>
<tr class="separator:ab0b35bd43d108b5aa853698f8d742857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec7a387953c396bbb68e0d3d3321db2"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;StringType, basicString&lt;T&gt;&gt;::value || royale::iterator::is_same&lt;StringType, std::string&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:a0ec7a387953c396bbb68e0d3d3321db2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0ec7a387953c396bbb68e0d3d3321db2">insert</a> (size_t pos, const StringType &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:a0ec7a387953c396bbb68e0d3d3321db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cd390895725401e2df6cf617a5db52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab6cd390895725401e2df6cf617a5db52">insert</a> (size_t pos, const char *s)</td></tr>
<tr class="separator:ab6cd390895725401e2df6cf617a5db52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fbf2166269477080c586b46ac37ef7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a15fbf2166269477080c586b46ac37ef7">insert</a> (size_t pos, const char *s, size_t n)</td></tr>
<tr class="separator:a15fbf2166269477080c586b46ac37ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199dbb2f9b29128a9fec0f8743b69b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a199dbb2f9b29128a9fec0f8743b69b0c">insert</a> (size_t pos, size_t n, char c)</td></tr>
<tr class="separator:a199dbb2f9b29128a9fec0f8743b69b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6ef29effecff12fa2d15e64852471d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#acf6ef29effecff12fa2d15e64852471d">insert</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> p, size_t n, char c)</td></tr>
<tr class="separator:acf6ef29effecff12fa2d15e64852471d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f316d2c7478359ad24884fffcfa003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a12f316d2c7478359ad24884fffcfa003">insert</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> p, char c)</td></tr>
<tr class="separator:a12f316d2c7478359ad24884fffcfa003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5566cecaae5553eed10f52abd86c8d7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab5566cecaae5553eed10f52abd86c8d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab5566cecaae5553eed10f52abd86c8d7">insert</a> (InputIterator_pos position, InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="separator:ab5566cecaae5553eed10f52abd86c8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df3e319b9e673d784b2c6a99708b29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a5df3e319b9e673d784b2c6a99708b29f">insert</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> position, std::initializer_list&lt; <a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a> &gt; il)</td></tr>
<tr class="separator:a5df3e319b9e673d784b2c6a99708b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e6d5a33f5a96e956cb7d1131904a72"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;StringType, basicString&lt;T&gt;&gt;::value || royale::iterator::is_same&lt;StringType, std::string&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:ab2e6d5a33f5a96e956cb7d1131904a72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab2e6d5a33f5a96e956cb7d1131904a72">assign</a> (const StringType &amp;str)</td></tr>
<tr class="memdesc:ab2e6d5a33f5a96e956cb7d1131904a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns new contents to the string, replacing its current contents, and modifying its size accordingly.  <a href="#ab2e6d5a33f5a96e956cb7d1131904a72">More...</a><br/></td></tr>
<tr class="separator:ab2e6d5a33f5a96e956cb7d1131904a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be21b5d4b844dc2cebeadd87c338b7a"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;StringType, basicString&lt;T&gt;&gt;::value || royale::iterator::is_same&lt;StringType, std::string&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:a2be21b5d4b844dc2cebeadd87c338b7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a2be21b5d4b844dc2cebeadd87c338b7a">assign</a> (const StringType &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:a2be21b5d4b844dc2cebeadd87c338b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c9defb1631834fb3c6be142ab1db08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a37c9defb1631834fb3c6be142ab1db08">assign</a> (const char *s)</td></tr>
<tr class="separator:a37c9defb1631834fb3c6be142ab1db08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa59de86a1f1fb31a9bca45a85054e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aaa59de86a1f1fb31a9bca45a85054e79">assign</a> (const char *s, size_t n)</td></tr>
<tr class="separator:aaa59de86a1f1fb31a9bca45a85054e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1329fd5731477f1005da989214292f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aef1329fd5731477f1005da989214292f">assign</a> (const char *str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:aef1329fd5731477f1005da989214292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67c803126a4f455d9bc0eeab89e18c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ac67c803126a4f455d9bc0eeab89e18c2">assign</a> (<a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;str)</td></tr>
<tr class="separator:ac67c803126a4f455d9bc0eeab89e18c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e0a6ed10c9176367a28f620d70ef6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a10e0a6ed10c9176367a28f620d70ef6a">assign</a> (std::initializer_list&lt; <a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a> &gt; il)</td></tr>
<tr class="separator:a10e0a6ed10c9176367a28f620d70ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ece82a1c139155d3f03daabca1986f"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;Value, typename basicString&lt;T&gt;::value_type&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:a12ece82a1c139155d3f03daabca1986f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a12ece82a1c139155d3f03daabca1986f">assign</a> (size_t n, Value val)</td></tr>
<tr class="separator:a12ece82a1c139155d3f03daabca1986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b71a6ecd9963429cfe7b3f6fb91ff14"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4b71a6ecd9963429cfe7b3f6fb91ff14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a4b71a6ecd9963429cfe7b3f6fb91ff14">assign</a> (InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="separator:a4b71a6ecd9963429cfe7b3f6fb91ff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cc608d2df35aa5cddde9f37d2e3090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad7cc608d2df35aa5cddde9f37d2e3090">remove</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> first, <a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> last)</td></tr>
<tr class="memdesc:ad7cc608d2df35aa5cddde9f37d2e3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements Removes from the string either a single element (position) or a range of elements ([first,last)).  <a href="#ad7cc608d2df35aa5cddde9f37d2e3090">More...</a><br/></td></tr>
<tr class="separator:ad7cc608d2df35aa5cddde9f37d2e3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88831af018636507e5ecda364afa7efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a88831af018636507e5ecda364afa7efa">remove</a> (size_t pos=0, size_t len=<a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a>)</td></tr>
<tr class="separator:a88831af018636507e5ecda364afa7efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b00e492ddfdcfc113015fc2b9e5c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa7b00e492ddfdcfc113015fc2b9e5c78">remove</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> position, size_t len=1)</td></tr>
<tr class="separator:aa7b00e492ddfdcfc113015fc2b9e5c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96eb8af14b243dfb01bacc218fa4120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad96eb8af14b243dfb01bacc218fa4120">erase</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> first, <a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> last)</td></tr>
<tr class="memdesc:ad96eb8af14b243dfb01bacc218fa4120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Erases from the string either a single element (position) or a range of elements ([first,last)).  <a href="#ad96eb8af14b243dfb01bacc218fa4120">More...</a><br/></td></tr>
<tr class="separator:ad96eb8af14b243dfb01bacc218fa4120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88acce72c9eb52042619d9e78a3d2e2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a88acce72c9eb52042619d9e78a3d2e2b">erase</a> (size_t pos=0, size_t len=<a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a>)</td></tr>
<tr class="separator:a88acce72c9eb52042619d9e78a3d2e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55aa3510cc6c84973925d6f33754b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab55aa3510cc6c84973925d6f33754b18">erase</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> position, size_t len=1)</td></tr>
<tr class="separator:ab55aa3510cc6c84973925d6f33754b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3278d52143eae5d0da08424b29e86ef6"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3278d52143eae5d0da08424b29e86ef6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a3278d52143eae5d0da08424b29e86ef6">replace</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> start, <a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html#a720a9923d1c9b04ed5f2ad0e1019a6b8">end</a>, InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="memdesc:a3278d52143eae5d0da08424b29e86ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing the elements from "start" to "end" with the element given in the range from "first" to "last".  <a href="#a3278d52143eae5d0da08424b29e86ef6">More...</a><br/></td></tr>
<tr class="separator:a3278d52143eae5d0da08424b29e86ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe100f515e26490931630620077bd392"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afe100f515e26490931630620077bd392"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#afe100f515e26490931630620077bd392">replace</a> (InputIterator_pos position, InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="memdesc:afe100f515e26490931630620077bd392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing vector elements with element given in the range from "first" to "last".  <a href="#afe100f515e26490931630620077bd392">More...</a><br/></td></tr>
<tr class="separator:afe100f515e26490931630620077bd392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab772f3d7c52813c01d31ea07115b072"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename ContainerType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if &lt; !std::is_convertible&lt;ContainerType, T&gt;::value &amp;&amp; !royale::iterator::is_iterator&lt;ContainerType&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:aab772f3d7c52813c01d31ea07115b072"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aab772f3d7c52813c01d31ea07115b072">replace</a> (InputIterator_pos position, const ContainerType &amp;v)</td></tr>
<tr class="memdesc:aab772f3d7c52813c01d31ea07115b072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing vector elements with the elements of another input container.  <a href="#aab772f3d7c52813c01d31ea07115b072">More...</a><br/></td></tr>
<tr class="separator:aab772f3d7c52813c01d31ea07115b072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8a29bb5e90dd9d7d17becec5064cb1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_start , typename InputIterator_end , typename ContainerType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_start&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_end&gt;::value&gt;::type, typename  = typename std::enable_if &lt; !std::is_convertible&lt;ContainerType, T&gt;::value &amp;&amp; !royale::iterator::is_iterator&lt;ContainerType&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ace8a29bb5e90dd9d7d17becec5064cb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ace8a29bb5e90dd9d7d17becec5064cb1">replace</a> (InputIterator_start start, InputIterator_end <a class="el" href="classroyale_1_1basic_string.html#a720a9923d1c9b04ed5f2ad0e1019a6b8">end</a>, const ContainerType &amp;v)</td></tr>
<tr class="memdesc:ace8a29bb5e90dd9d7d17becec5064cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing the elements from "start" to "end" with the elements in the input container.  <a href="#ace8a29bb5e90dd9d7d17becec5064cb1">More...</a><br/></td></tr>
<tr class="separator:ace8a29bb5e90dd9d7d17becec5064cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11095afca67c0cc02d09dc88b5020d24"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType , typename  = typename std::enable_if &lt; !std::is_convertible&lt;ContainerType, T&gt;::value &amp;&amp; !royale::iterator::is_iterator&lt;ContainerType&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a11095afca67c0cc02d09dc88b5020d24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a11095afca67c0cc02d09dc88b5020d24">replace</a> (size_t index, const ContainerType &amp;v)</td></tr>
<tr class="memdesc:a11095afca67c0cc02d09dc88b5020d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing the elements beginning at index with all items held by the container v.  <a href="#a11095afca67c0cc02d09dc88b5020d24">More...</a><br/></td></tr>
<tr class="separator:a11095afca67c0cc02d09dc88b5020d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6469076873a7f9af366f758eb5ca86da"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6469076873a7f9af366f758eb5ca86da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6469076873a7f9af366f758eb5ca86da">replace</a> (size_t index, InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="memdesc:a6469076873a7f9af366f758eb5ca86da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing the elements starting at index with the given range from "first" to "last".  <a href="#a6469076873a7f9af366f758eb5ca86da">More...</a><br/></td></tr>
<tr class="separator:a6469076873a7f9af366f758eb5ca86da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdbb26ba57ba0604bbf436ca33a2eb8"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;StringType, basicString&lt;T&gt;&gt;::value || royale::iterator::is_same&lt;StringType, std::string&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:a7fdbb26ba57ba0604bbf436ca33a2eb8"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7fdbb26ba57ba0604bbf436ca33a2eb8">find</a> (const StringType &amp;str, size_t pos=0) const </td></tr>
<tr class="memdesc:a7fdbb26ba57ba0604bbf436ca33a2eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Searches the string for the first occurrence of the sequence specified by its arguments.  <a href="#a7fdbb26ba57ba0604bbf436ca33a2eb8">More...</a><br/></td></tr>
<tr class="separator:a7fdbb26ba57ba0604bbf436ca33a2eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc768faab3e6e698e45b6c0be6261db3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#afc768faab3e6e698e45b6c0be6261db3">find</a> (const char *str, size_t pos=0) const </td></tr>
<tr class="separator:afc768faab3e6e698e45b6c0be6261db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b6f5dd7aa4b979b5a7fb72e2264a1f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a13b6f5dd7aa4b979b5a7fb72e2264a1f">find</a> (const char *s, size_t pos, <a class="el" href="classroyale_1_1basic_string.html#a114882b7ee678c295e29f66972950f4d">size_type</a> n) const </td></tr>
<tr class="separator:a13b6f5dd7aa4b979b5a7fb72e2264a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35b144d76ff9505e6fecc93938def19"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ae35b144d76ff9505e6fecc93938def19">find</a> (char c, size_t pos=0) const </td></tr>
<tr class="separator:ae35b144d76ff9505e6fecc93938def19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57777cf5c33d3c25b4769efeacc359e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa57777cf5c33d3c25b4769efeacc359e">compare</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:aa57777cf5c33d3c25b4769efeacc359e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings Compares the value of the string object (or a substring) to the sequence of characters specified by its arguments.  <a href="#aa57777cf5c33d3c25b4769efeacc359e">More...</a><br/></td></tr>
<tr class="separator:aa57777cf5c33d3c25b4769efeacc359e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3808e4c5fbeced97cf42b01a5c08340"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa3808e4c5fbeced97cf42b01a5c08340">compare</a> (size_t pos, size_t len, const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="separator:aa3808e4c5fbeced97cf42b01a5c08340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099637c79d479e8c5520c51acdce8c27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a099637c79d479e8c5520c51acdce8c27">compare</a> (size_t pos, size_t nlen, const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str, size_t subpos, size_t sublen) const </td></tr>
<tr class="separator:a099637c79d479e8c5520c51acdce8c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b63f15cbd5f591a7711e5b11c64328"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a50b63f15cbd5f591a7711e5b11c64328">compare</a> (size_t pos, size_t nlen, const char *s, size_t subpos, size_t sublen) const </td></tr>
<tr class="separator:a50b63f15cbd5f591a7711e5b11c64328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab225b72d849e451c9014429432ac9661"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab225b72d849e451c9014429432ac9661">compare</a> (const char *s) const </td></tr>
<tr class="separator:ab225b72d849e451c9014429432ac9661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a490ebe82b8ee80b5c4133604efc888"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a1a490ebe82b8ee80b5c4133604efc888">compare</a> (size_t pos, size_t nlen, const char *s, size_t n) const </td></tr>
<tr class="separator:a1a490ebe82b8ee80b5c4133604efc888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4e880d246daaf8dbb1e8179ca61bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a4f4e880d246daaf8dbb1e8179ca61bd9">substr</a> (size_t pos, size_t len) const </td></tr>
<tr class="memdesc:a4f4e880d246daaf8dbb1e8179ca61bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a substring.  <a href="#a4f4e880d246daaf8dbb1e8179ca61bd9">More...</a><br/></td></tr>
<tr class="separator:a4f4e880d246daaf8dbb1e8179ca61bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93b4a2fe21f91028344afeb6a0ac568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa93b4a2fe21f91028344afeb6a0ac568">pop_back</a> ()</td></tr>
<tr class="memdesc:aa93b4a2fe21f91028344afeb6a0ac568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element in the string, effectively reducing the container size by one.  <a href="#aa93b4a2fe21f91028344afeb6a0ac568">More...</a><br/></td></tr>
<tr class="separator:aa93b4a2fe21f91028344afeb6a0ac568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7695f287c0aee6474e3366f7f6f389f7"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7695f287c0aee6474e3366f7f6f389f7">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:a7695f287c0aee6474e3366f7f6f389f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element.  <a href="#a7695f287c0aee6474e3366f7f6f389f7">More...</a><br/></td></tr>
<tr class="separator:a7695f287c0aee6474e3366f7f6f389f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed81540a238ab1c8a56530f25b71f2c1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aed81540a238ab1c8a56530f25b71f2c1">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:aed81540a238ab1c8a56530f25b71f2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element.  <a href="#aed81540a238ab1c8a56530f25b71f2c1">More...</a><br/></td></tr>
<tr class="separator:aed81540a238ab1c8a56530f25b71f2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c509c3292d15c832190dd2e56157680"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680">at</a> (size_t index)</td></tr>
<tr class="memdesc:a5c509c3292d15c832190dd2e56157680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element.  <a href="#a5c509c3292d15c832190dd2e56157680">More...</a><br/></td></tr>
<tr class="separator:a5c509c3292d15c832190dd2e56157680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2927b2043c70b3ea78ac9141866c2a55"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a2927b2043c70b3ea78ac9141866c2a55">at</a> (size_t index) const </td></tr>
<tr class="memdesc:a2927b2043c70b3ea78ac9141866c2a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element.  <a href="#a2927b2043c70b3ea78ac9141866c2a55">More...</a><br/></td></tr>
<tr class="separator:a2927b2043c70b3ea78ac9141866c2a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc01fd5b4ae4c87d37b71ba0976d90da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#afc01fd5b4ae4c87d37b71ba0976d90da">operator=</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:afc01fd5b4ae4c87d37b71ba0976d90da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign another royale compliant string.  <a href="#afc01fd5b4ae4c87d37b71ba0976d90da">More...</a><br/></td></tr>
<tr class="separator:afc01fd5b4ae4c87d37b71ba0976d90da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b3431347eae688334fd7855d49382f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a83b3431347eae688334fd7855d49382f">operator=</a> (<a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:a83b3431347eae688334fd7855d49382f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move elements to another royale compliant string.  <a href="#a83b3431347eae688334fd7855d49382f">More...</a><br/></td></tr>
<tr class="separator:a83b3431347eae688334fd7855d49382f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5faa84d758be2c15f49c3e6997dec6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ac5faa84d758be2c15f49c3e6997dec6a">operator=</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:ac5faa84d758be2c15f49c3e6997dec6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the contents of an STL compliant string container by replacing container's current contents if necessary and modifying its size accordingly.  <a href="#ac5faa84d758be2c15f49c3e6997dec6a">More...</a><br/></td></tr>
<tr class="separator:ac5faa84d758be2c15f49c3e6997dec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06c964b23013a298137907e97bcf1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9f06c964b23013a298137907e97bcf1d">operator=</a> (const T *str)</td></tr>
<tr class="memdesc:a9f06c964b23013a298137907e97bcf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the contents of an C-Style compliant string container by replacing container's current contents if necessary and modifying its size accordingly.  <a href="#a9f06c964b23013a298137907e97bcf1d">More...</a><br/></td></tr>
<tr class="separator:a9f06c964b23013a298137907e97bcf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b9d69ca31d55f25190faf2154f7677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a80b9d69ca31d55f25190faf2154f7677">operator=</a> (const T str)</td></tr>
<tr class="memdesc:a80b9d69ca31d55f25190faf2154f7677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a character to a royale compliant string container by replacing container's current contents and modifying its size accordingly.  <a href="#a80b9d69ca31d55f25190faf2154f7677">More...</a><br/></td></tr>
<tr class="separator:a80b9d69ca31d55f25190faf2154f7677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc5379d5781fdcac8bcc499e4fe7773"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7cc5379d5781fdcac8bcc499e4fe7773">operator==</a> (const std::basic_string&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a7cc5379d5781fdcac8bcc499e4fe7773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with an STL compliant vector.  <a href="#a7cc5379d5781fdcac8bcc499e4fe7773">More...</a><br/></td></tr>
<tr class="separator:a7cc5379d5781fdcac8bcc499e4fe7773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceff1b415565de95e42174eb9ca1f79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7ceff1b415565de95e42174eb9ca1f79">operator==</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a7ceff1b415565de95e42174eb9ca1f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with a royale compliant string.  <a href="#a7ceff1b415565de95e42174eb9ca1f79">More...</a><br/></td></tr>
<tr class="separator:a7ceff1b415565de95e42174eb9ca1f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058d0e17bca7e293ebb7a9ece4d66b1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a058d0e17bca7e293ebb7a9ece4d66b1d">operator==</a> (const T *str) const </td></tr>
<tr class="memdesc:a058d0e17bca7e293ebb7a9ece4d66b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with a C-Style string.  <a href="#a058d0e17bca7e293ebb7a9ece4d66b1d">More...</a><br/></td></tr>
<tr class="separator:a058d0e17bca7e293ebb7a9ece4d66b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c155f20985f6a8c371c81862c559b0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a4c155f20985f6a8c371c81862c559b0c">operator!=</a> (const std::basic_string&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a4c155f20985f6a8c371c81862c559b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with an STL compliant string.  <a href="#a4c155f20985f6a8c371c81862c559b0c">More...</a><br/></td></tr>
<tr class="separator:a4c155f20985f6a8c371c81862c559b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f12322ce9719d9f8f6cd5d148bbc1e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a1f12322ce9719d9f8f6cd5d148bbc1e7">operator!=</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a1f12322ce9719d9f8f6cd5d148bbc1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with a royale compliant string.  <a href="#a1f12322ce9719d9f8f6cd5d148bbc1e7">More...</a><br/></td></tr>
<tr class="separator:a1f12322ce9719d9f8f6cd5d148bbc1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b558cbb9058a238d0985e38c8b6365"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a20b558cbb9058a238d0985e38c8b6365">operator!=</a> (const T *str) const </td></tr>
<tr class="memdesc:a20b558cbb9058a238d0985e38c8b6365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with a C-Style string.  <a href="#a20b558cbb9058a238d0985e38c8b6365">More...</a><br/></td></tr>
<tr class="separator:a20b558cbb9058a238d0985e38c8b6365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad289129843a85f6da3a25921fe479f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7ad289129843a85f6da3a25921fe479f">operator&lt;</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a7ad289129843a85f6da3a25921fe479f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks less-than relation with a royale compliant string.  <a href="#a7ad289129843a85f6da3a25921fe479f">More...</a><br/></td></tr>
<tr class="separator:a7ad289129843a85f6da3a25921fe479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326406f8b4f3c430150441c8f1152377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a326406f8b4f3c430150441c8f1152377">clear</a> ()</td></tr>
<tr class="memdesc:a326406f8b4f3c430150441c8f1152377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the string (which are destroyed), leaving the container with a size of 0.  <a href="#a326406f8b4f3c430150441c8f1152377">More...</a><br/></td></tr>
<tr class="separator:a326406f8b4f3c430150441c8f1152377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaa2ccdcfac29271a5d35110ff2fad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0eaa2ccdcfac29271a5d35110ff2fad9">swap</a> (<a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;string)</td></tr>
<tr class="memdesc:a0eaa2ccdcfac29271a5d35110ff2fad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a data swap (convenience function to call classswap) Swaps the given string data with the current one.  <a href="#a0eaa2ccdcfac29271a5d35110ff2fad9">More...</a><br/></td></tr>
<tr class="separator:a0eaa2ccdcfac29271a5d35110ff2fad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de316077ddd24a4cad3df61d155438b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9de316077ddd24a4cad3df61d155438b">resize</a> (size_t newSize)</td></tr>
<tr class="memdesc:a9de316077ddd24a4cad3df61d155438b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the string to the given allocation size and allocates the buffers (it may shrink)  <a href="#a9de316077ddd24a4cad3df61d155438b">More...</a><br/></td></tr>
<tr class="separator:a9de316077ddd24a4cad3df61d155438b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c953106f528c47f9f3e80d201a7f79d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0c953106f528c47f9f3e80d201a7f79d">reserve</a> (size_t <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3">size</a>)</td></tr>
<tr class="memdesc:a0c953106f528c47f9f3e80d201a7f79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the string to a higher allocation size and allocates the buffers.  <a href="#a0c953106f528c47f9f3e80d201a7f79d">More...</a><br/></td></tr>
<tr class="separator:a0c953106f528c47f9f3e80d201a7f79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552e9b0cbbf0be9a2594ee2a7afc7fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6552e9b0cbbf0be9a2594ee2a7afc7fc">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a6552e9b0cbbf0be9a2594ee2a7afc7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the string's allocation to it's size.  <a href="#a6552e9b0cbbf0be9a2594ee2a7afc7fc">More...</a><br/></td></tr>
<tr class="separator:a6552e9b0cbbf0be9a2594ee2a7afc7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873798ac4037d14b84a30112548bf8fa"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a873798ac4037d14b84a30112548bf8fa">c_str</a> () const </td></tr>
<tr class="memdesc:a873798ac4037d14b84a30112548bf8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the royale string object to a C-Style array.  <a href="#a873798ac4037d14b84a30112548bf8fa">More...</a><br/></td></tr>
<tr class="separator:a873798ac4037d14b84a30112548bf8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a9bacf8fdf1c7bb9a6aa7aa1efc229"><td class="memItemLeft" align="right" valign="top">std::basic_string&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad8a9bacf8fdf1c7bb9a6aa7aa1efc229">toStdString</a> () const </td></tr>
<tr class="memdesc:ad8a9bacf8fdf1c7bb9a6aa7aa1efc229"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::basic_string which might be used outside the library by the application for further processing.  <a href="#ad8a9bacf8fdf1c7bb9a6aa7aa1efc229">More...</a><br/></td></tr>
<tr class="separator:ad8a9bacf8fdf1c7bb9a6aa7aa1efc229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eb98ed08a7881fc13df7bc3cb0590b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a83eb98ed08a7881fc13df7bc3cb0590b">max_size</a> () const </td></tr>
<tr class="memdesc:a83eb98ed08a7881fc13df7bc3cb0590b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max_size of the string.  <a href="#a83eb98ed08a7881fc13df7bc3cb0590b">More...</a><br/></td></tr>
<tr class="separator:a83eb98ed08a7881fc13df7bc3cb0590b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e0e3a23c9a402109a736e89c09bb68"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ae1e0e3a23c9a402109a736e89c09bb68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ae1e0e3a23c9a402109a736e89c09bb68">assign</a> (std::initializer_list&lt; typename <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a> &gt; il)</td></tr>
<tr class="separator:ae1e0e3a23c9a402109a736e89c09bb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56354339ca3e21a552747948e7e1cede"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename , typename , typename &gt; </td></tr>
<tr class="memitem:a56354339ca3e21a552747948e7e1cede"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a56354339ca3e21a552747948e7e1cede">insert</a> (InputIterator_pos position, InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="separator:a56354339ca3e21a552747948e7e1cede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0ff03060a9a2739bff8e1881e49cf6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abd0ff03060a9a2739bff8e1881e49cf6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#abd0ff03060a9a2739bff8e1881e49cf6">insert</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> position, std::initializer_list&lt; typename <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a> &gt; il)</td></tr>
<tr class="separator:abd0ff03060a9a2739bff8e1881e49cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3d39bc7c6043436b48e252dddf08b5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </td></tr>
<tr class="memitem:aec3d39bc7c6043436b48e252dddf08b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aec3d39bc7c6043436b48e252dddf08b5">replace</a> (<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> start, <a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html#a720a9923d1c9b04ed5f2ad0e1019a6b8">end</a>, InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="separator:aec3d39bc7c6043436b48e252dddf08b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dfa629042c710a532991112d089ca6"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_start , typename InputIterator_end , typename ContainerType , typename , typename , typename &gt; </td></tr>
<tr class="memitem:a69dfa629042c710a532991112d089ca6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a69dfa629042c710a532991112d089ca6">replace</a> (InputIterator_start start, InputIterator_end <a class="el" href="classroyale_1_1basic_string.html#a720a9923d1c9b04ed5f2ad0e1019a6b8">end</a>, const ContainerType &amp;v)</td></tr>
<tr class="separator:a69dfa629042c710a532991112d089ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ef927fed9e5711461c16e9a954c6c0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename , typename , typename &gt; </td></tr>
<tr class="memitem:ac1ef927fed9e5711461c16e9a954c6c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ac1ef927fed9e5711461c16e9a954c6c0">replace</a> (InputIterator_pos position, InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="separator:ac1ef927fed9e5711461c16e9a954c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68bd65e38f23c0f11af5640fe326e44"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename ContainerType , typename , typename &gt; </td></tr>
<tr class="memitem:af68bd65e38f23c0f11af5640fe326e44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af68bd65e38f23c0f11af5640fe326e44">replace</a> (InputIterator_pos position, const ContainerType &amp;v)</td></tr>
<tr class="separator:af68bd65e38f23c0f11af5640fe326e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d678634950c39662c1b65f8e5358857"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType , typename &gt; </td></tr>
<tr class="memitem:a4d678634950c39662c1b65f8e5358857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a4d678634950c39662c1b65f8e5358857">replace</a> (size_t index, const ContainerType &amp;v)</td></tr>
<tr class="separator:a4d678634950c39662c1b65f8e5358857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7b0eac50204e4ab0e067b48be66752"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </td></tr>
<tr class="memitem:aee7b0eac50204e4ab0e067b48be66752"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aee7b0eac50204e4ab0e067b48be66752">replace</a> (size_t index, InputIterator_first first, InputIterator_last last)</td></tr>
<tr class="separator:aee7b0eac50204e4ab0e067b48be66752"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af078b6af10bf0b399622770dd0392cbb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af078b6af10bf0b399622770dd0392cbb">fromStdString</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:af078b6af10bf0b399622770dd0392cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given std::basic_string (STL) to the string type used by the royale API.  <a href="#af078b6af10bf0b399622770dd0392cbb">More...</a><br/></td></tr>
<tr class="separator:af078b6af10bf0b399622770dd0392cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20a3a242190219153949708d4f5bf2c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af20a3a242190219153949708d4f5bf2c">fromCArray</a> (const T *str)</td></tr>
<tr class="memdesc:af20a3a242190219153949708d4f5bf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C-Style array to the string type used by the royale API.  <a href="#af20a3a242190219153949708d4f5bf2c">More...</a><br/></td></tr>
<tr class="separator:af20a3a242190219153949708d4f5bf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a7b5db816988510123be91a61037f"><td class="memTemplParams" colspan="2">template&lt;typename... Dummy, typename U , typename Type  = T&gt; </td></tr>
<tr class="memitem:a4d1a7b5db816988510123be91a61037f"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if<br class="typebreak"/>
&lt; std::is_same&lt; Type, char &gt;<br class="typebreak"/>
::value, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; Type &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a4d1a7b5db816988510123be91a61037f">fromAny</a> (const U value)</td></tr>
<tr class="memdesc:a4d1a7b5db816988510123be91a61037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to String from any Type.  <a href="#a4d1a7b5db816988510123be91a61037f">More...</a><br/></td></tr>
<tr class="separator:a4d1a7b5db816988510123be91a61037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec87aba6b9ebf78fd8512650a5d74c6"><td class="memTemplParams" colspan="2">template&lt;typename... Dummy, typename U , typename Type  = T&gt; </td></tr>
<tr class="memitem:a7ec87aba6b9ebf78fd8512650a5d74c6"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if<br class="typebreak"/>
&lt; std::is_same&lt; Type, wchar_t &gt;<br class="typebreak"/>
::value, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; Type &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7ec87aba6b9ebf78fd8512650a5d74c6">fromAny</a> (const U value)</td></tr>
<tr class="memdesc:a7ec87aba6b9ebf78fd8512650a5d74c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to WString from any Type.  <a href="#a7ec87aba6b9ebf78fd8512650a5d74c6">More...</a><br/></td></tr>
<tr class="separator:a7ec87aba6b9ebf78fd8512650a5d74c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a5b23defbab1196cddbee12c1e7f46"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a05a5b23defbab1196cddbee12c1e7f46">fromInt</a> (int value)</td></tr>
<tr class="memdesc:a05a5b23defbab1196cddbee12c1e7f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to String from Int.  <a href="#a05a5b23defbab1196cddbee12c1e7f46">More...</a><br/></td></tr>
<tr class="separator:a05a5b23defbab1196cddbee12c1e7f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab781ffb10caede90dd9a495040f63c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8ab781ffb10caede90dd9a495040f63c">fromUInt</a> (unsigned int value)</td></tr>
<tr class="memdesc:a8ab781ffb10caede90dd9a495040f63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to String from unsigned Int.  <a href="#a8ab781ffb10caede90dd9a495040f63c">More...</a><br/></td></tr>
<tr class="separator:a8ab781ffb10caede90dd9a495040f63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9e942a9588aa0e7e734e106ce30383"><td class="memItemLeft" align="right" valign="top">static std::basic_string&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aea9e942a9588aa0e7e734e106ce30383">toStdString</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:aea9e942a9588aa0e7e734e106ce30383"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::basic_string which might be used if the royale compliant string is a const.  <a href="#aea9e942a9588aa0e7e734e106ce30383">More...</a><br/></td></tr>
<tr class="separator:aea9e942a9588aa0e7e734e106ce30383"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3441c25480c3727315bda167a6bd6e55"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a> = ( (size_t) ~0)</td></tr>
<tr class="separator:a3441c25480c3727315bda167a6bd6e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e49999c31e34b4c5e29b7e6dd1b775"><td class="memItemLeft" align="right" valign="top">static const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ac7e49999c31e34b4c5e29b7e6dd1b775">EOS</a> = 0</td></tr>
<tr class="memdesc:ac7e49999c31e34b4c5e29b7e6dd1b775"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NUL terminator, which is '\0' for T = char, and L'\0' for T = wchar_t.  <a href="#ac7e49999c31e34b4c5e29b7e6dd1b775">More...</a><br/></td></tr>
<tr class="separator:ac7e49999c31e34b4c5e29b7e6dd1b775"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9e83f590b905885332f9979ba866512c"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9e83f590b905885332f9979ba866512c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9e83f590b905885332f9979ba866512c">classswap</a> (<a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; U &gt; &amp;first, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; U &gt; &amp;second)</td></tr>
<tr class="separator:a9e83f590b905885332f9979ba866512c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454da36bff6bdbad033ccb9da2cc400e"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a454da36bff6bdbad033ccb9da2cc400e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a454da36bff6bdbad033ccb9da2cc400e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; U &gt; &amp;str)</td></tr>
<tr class="separator:a454da36bff6bdbad033ccb9da2cc400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ab114ad5253c9066fb12a30b68a2bc132"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1iterator_1_1royale__const__iterator.html">royale::iterator::royale_const_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a99bb5737c3b41f8cd97da3dbfdaef4b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a99bb5737c3b41f8cd97da3dbfdaef4b0">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a51d5f3e7b20ea82ebb63a7dd0a851c3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a51d5f3e7b20ea82ebb63a7dd0a851c3f">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b97b056944f5e5c0a37c54947308c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1iterator_1_1royale__const__reverse__iterator.html">royale::iterator::royale_const_reverse_iterator</a>&lt; <a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9e483d21c3e48468b5cf686a15be1ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ptrdiff_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ac9e483d21c3e48468b5cf686a15be1ad">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a23f69382a3f5949725fa552b58ae29ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1iterator_1_1royale__iterator.html">royale::iterator::royale_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator definitions. </p>

</div>
</div>
<a class="anchor" id="a920a63d18280f2a62110199a80912822"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a920a63d18280f2a62110199a80912822">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d539cda1422c12a7dfa80f82020dfb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a5d539cda1422c12a7dfa80f82020dfb8">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae98bf79c04dc2a790a5e36373e045121"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1iterator_1_1royale__reverse__iterator.html">royale::iterator::royale_reverse_iterator</a>&lt; <a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ae98bf79c04dc2a790a5e36373e045121">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a114882b7ee678c295e29f66972950f4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a114882b7ee678c295e29f66972950f4d">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae26b6f53a1c7fe05800f3124824c8344"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::char_traits&lt;T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ae26b6f53a1c7fe05800f3124824c8344">traits_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8faf6a582542b8cdc384b0eee904679e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General String definitions. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a849cb5c82de63707e558bab9996f8ef9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Template implementation.</p>
<p>General constructor, which does not allocate memory and sets everything to it's default </p>

</div>
</div>
<a class="anchor" id="aa16c536bb88c352db8a89039d4b1ec64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-Constructor for royale compliant string. </p>
<p>Copy constructor which allows creation of a royale compliant string from another royale compliant string - (NOTE: performs a deep copy!)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The royale vector which's memory shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56594a8cd85bd045aef2d0e3f9d091b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-Constructor for STL compliant string (std::string) </p>
<p>Copy constructor which allows creation of a royale compliant string from a STL compliant string - (NOTE: performs a deep copy!)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The STL string to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab07d1648687b09e263059886b174cbdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-Constructor for royale compliant string. </p>
<p>Constructor which allows creation of a royale compliant string by moving memory (NOTE: performs a shallow copy!)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The royale string which's memory shall be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a095d9bed011982b11084913f2c69f7fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code><a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows passing a royale compliant string and add it at a given position - the caller might also limit the length that shall be copied (NOTE: performs a deep copy!) </p>
<p>If the len would exceed the length of str then all bytes till the end of str are copied to the new string object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The royale string which shall be copied </td></tr>
    <tr><td class="paramname">pos</td><td>The position where to start to copy bytes </td></tr>
    <tr><td class="paramname">len</td><td>The length/amount of bytes that shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11ebe53d7353e3491ebc116643c467a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code><a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows passing a STL compliant string and add it at a given position - the caller might also limit the length that shall be copied (NOTE: performs a deep copy!) </p>
<p>If the len would exceed the length of str then all bytes till the end of str are copied to the new string object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The STL compliant string which shall be copied </td></tr>
    <tr><td class="paramname">pos</td><td>The position where to start to copy bytes </td></tr>
    <tr><td class="paramname">len</td><td>The length/amount of bytes that shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a060d202e53cf9ae966a13c44df197a5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows passing a C-Style string to create a royale compliant string (NOTE: performs a deep copy!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The C-Style compliant string which shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a295b071b29fec507d5f6484bff0653cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows passing a C-Style string to create a royale compliant string by copying the first n bytes (NOTE: performs a deep copy!) </p>
<p>(NOTE: The next paragraph is different to std::string!) If n is bigger than the length of s, then n is allocated and the length of s is used for copying - this results in a string with unused allocated space and the value of where s points to.</p>
<p>If n is smaller than the length of s, then n is allocated and only n bytes from s are copied to the string object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The C-Style compliant string which shall be copied </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c39fec67ca9c71be71ac3b7c79cc8e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows creating a royale compliant string with n slots which are initialized by character c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of slots that shall be reserved </td></tr>
    <tr><td class="paramname">c</td><td>The character which is used for the slot's initialization </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0783454d063ac865be29c630a23bbe57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer list initialization to initialize a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a334aade8c84f9ea903687ab4a0a6ec9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::~<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Clears the string's allocated memory by performing deletion </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af08c6fb824a972346fff20ea92794331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the end of the string, after its current last element and returns the actual string element. </p>
<p>The content of str is copied to the new element (NOTE: a deep copy is performed!). This effectively increases the container size, which causes an automatic reallocation of the allocated storage space if -and only if- the new string size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a8232e4e559b251e4d304b9e520d7643e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adcc7fbaabcaa7911379e33a23f044ea7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a71f4ac053c4b73faf7c71fde481e4387"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38cc3ed778fbb661776391595993e119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a024faa49d8010fbcb0372d25a284c91f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad153702cf2e8d04d728dbd62ab659940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeae2cfa6e7f521e2a63a0aedd3b46375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2e6d5a33f5a96e956cb7d1131904a72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename StringType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns new contents to the string, replacing its current contents, and modifying its size accordingly. </p>
<p>Any elements held in the container before the call are destroyed or replaced by newly constructed elements (no assignments of elements take place). This causes an automatic reallocation of the allocated storage space if - and only if - the new vector size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a2be21b5d4b844dc2cebeadd87c338b7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename StringType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37c9defb1631834fb3c6be142ab1db08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa59de86a1f1fb31a9bca45a85054e79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aef1329fd5731477f1005da989214292f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac67c803126a4f455d9bc0eeab89e18c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a10e0a6ed10c9176367a28f620d70ef6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;&amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12ece82a1c139155d3f03daabca1986f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Value , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b71a6ecd9963429cfe7b3f6fb91ff14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1e0e3a23c9a402109a736e89c09bb68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;&amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; typename <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c509c3292d15c832190dd2e56157680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element. </p>
<p>The function automatically checks whether index is within the bounds of valid elements in the string, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size). This is in contrast with member operator[], that does not check against bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the string's storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the string </dd></dl>

</div>
</div>
<a class="anchor" id="a2927b2043c70b3ea78ac9141866c2a55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element. </p>
<p>The function automatically checks whether index is within the bounds of valid elements in the string, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size). This is in contrast with member operator[], that does not check against bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the string's storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the string </dd></dl>

</div>
</div>
<a class="anchor" id="a64d27ea55b0638d7d3cf451a8eeba4c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the string. </p>
<p>Calling this function on an empty vector will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the last element in the string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the string is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f6e825f914dce79aacefded90b3bfa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a27e03cf2945f5219883ce3a40940b9bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first position Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator to the begin of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a98cb764f7500123b619ba6881243092c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a873798ac4037d14b84a30112548bf8fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the royale string object to a C-Style array. </p>
<dl class="section return"><dt>Returns</dt><dd>T* The C-Style Array </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a7db4b08f705cfc1a6a7a28d41f76e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of allocated slots which are maintained by the vector These allocated slots might be used or unused (refer to <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3" title="Returns the actual size/length of the string (this is the used amount of slots in the allocated area)...">size()</a> for checking the <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3" title="Returns the actual size/length of the string (this is the used amount of slots in the allocated area)...">size()</a> itself) The implicitly added NUL termination is not counted as part of the capacity. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of allocated slots for the element type which is bound to the string </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b0fb6f48077ea64ff5327c3911836e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the begin of the string (first position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator to the begin of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a62ed31b25b1278756b1c3f75d3750482"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad6312883cb35f8a8bb219b79f64ff043"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end of the string (last position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator to the end of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a51088e9351dcaa4cab77989cc720aae0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a326406f8b4f3c430150441c8f1152377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the string (which are destroyed), leaving the container with a size of 0. </p>
<p>A reallocation is not performed and the string's capacity is destroyed (everything is freed). </p>

</div>
</div>
<a class="anchor" id="aa57777cf5c33d3c25b4769efeacc359e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare strings Compares the value of the string object (or a substring) to the sequence of characters specified by its arguments. </p>
<p>The compared string is the value of the string object or -if the signature used has a pos and a len parameters- the substring that begins at its character in position pos and spans len characters. This string is compared to a comparing string, which is determined by the other arguments passed to the function.</p>
<p>Parameters</p>
<ul>
<li>str Another string object, used entirely (or partially) as the comparing string.</li>
</ul>
<ul>
<li>pos Position of the first character in the compared string. If this is greater than the string length, it throws out_of_range. Note: The first character is denoted by a value of 0 (not 1).</li>
</ul>
<ul>
<li>len Length of compared string (if the string is shorter, as many characters as possible). A value of string::npos indicates all characters until the end of the string. subpos, sublen Same as pos and len above, but for the comparing string.</li>
</ul>
<ul>
<li>s Pointer to an array of characters. If argument n is specified (4), the first n characters in the array are used as the comparing string. Otherwise (3), a null-terminated sequence is expected: the length of the sequence with the characters to use as comparing string is determined by the first occurrence of a null character.</li>
<li>n Number of characters to compare.</li>
</ul>
<p>Return Value Returns a signed integral indicating the relation between the strings: value relation between compared string and comparing string 0 They compare equal &lt;0 Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter. &gt;0 Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer. </p>

</div>
</div>
<a class="anchor" id="aa3808e4c5fbeced97cf42b01a5c08340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a099637c79d479e8c5520c51acdce8c27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50b63f15cbd5f591a7711e5b11c64328"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab225b72d849e451c9014429432ac9661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a490ebe82b8ee80b5c4133604efc888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a70a8716f95080111dca7abe88eb4db58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the reverse begin of the string (last position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator to the reverse begin of a string </dd></dl>

</div>
</div>
<a class="anchor" id="aebf1ab1304690abceec8b1c3a3f44956"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a205596ff77fbc7297e2b8d1f34deadae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator to the reverse end of the string (first position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator to the reverse end of a string </dd></dl>

</div>
</div>
<a class="anchor" id="a629f982fe719d3b59f8b682c4a7ab188"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9354acd2c34f8a317da08a3d51f3627"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a direct pointer to the memory array used internally by the string to store its owned elements. </p>
<p>Because elements in the string are guaranteed to be stored in contiguous storage locations in the same order as represented by the string, the pointer retrieved can be offset to access any element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>const T* A pointer to the first element in the array used internally by the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a61c32ccae743c4e5be4503a73e668921"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the string is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if the string is empty - otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a720a9923d1c9b04ed5f2ad0e1019a6b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the last position Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator to the end of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="ac142c88f4c79c3dafd315a052210c92e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad96eb8af14b243dfb01bacc218fa4120"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase elements Erases from the string either a single element (position) or a range of elements ([first,last)). </p>
<p>This effectively reduces the container size by the number of elements removed, which are destroyed.</p>
<p>Because strings use an array as their underlying storage, erasing elements in positions other than the vector end causes the container to relocate all the elements after the segment erased to their new positions. This is generally an inefficient operation compared to the one performed for the same operation by other kinds of sequence containers (such as list or forward_list).</p>
<p>A faster operation is <a class="el" href="classroyale_1_1basic_string.html#ad7cc608d2df35aa5cddde9f37d2e3090" title="Removes elements Removes from the string either a single element (position) or a range of elements ([...">remove()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>iterator The iterator position to the first element after the deleted range </dd></dl>

</div>
</div>
<a class="anchor" id="a88acce72c9eb52042619d9e78a3d2e2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code><a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab55aa3510cc6c84973925d6f33754b18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7fdbb26ba57ba0604bbf436ca33a2eb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename StringType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;StringType, basicString&lt;T&gt;&gt;::value || royale::iterator::is_same&lt;StringType, std::string&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find Searches the string for the first occurrence of the sequence specified by its arguments. </p>
<p>When pos is specified, the search only includes characters at or after position pos, ignoring any possible occurrences that include characters before pos.</p>
<p>Notice whenever more than one character is being searched for, it is not enough that just one of these characters match, but the entire sequence must match.</p>
<dl class="section return"><dt>Returns</dt><dd>The position of the first character of the first match. If no matches were found, the function returns string::npos. </dd></dl>

</div>
</div>
<a class="anchor" id="afc768faab3e6e698e45b6c0be6261db3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a13b6f5dd7aa4b979b5a7fb72e2264a1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#a114882b7ee678c295e29f66972950f4d">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae35b144d76ff9505e6fecc93938def19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d1a7b5db816988510123be91a61037f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename... Dummy, typename U , typename Type  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt; std::is_same&lt;Type, char&gt;::value, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;Type&gt; &gt;::type <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromAny </td>
          <td>(</td>
          <td class="paramtype">const U&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to String from any Type. </p>

</div>
</div>
<a class="anchor" id="a7ec87aba6b9ebf78fd8512650a5d74c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename... Dummy, typename U , typename Type  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt; std::is_same&lt;Type, wchar_t&gt;::value, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;Type&gt; &gt;::type <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromAny </td>
          <td>(</td>
          <td class="paramtype">const U&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to WString from any Type. </p>

</div>
</div>
<a class="anchor" id="af20a3a242190219153949708d4f5bf2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromCArray </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given C-Style array to the string type used by the royale API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The C-Style array which should be converted to the royale API vector format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The royale API compliant string format </dd></dl>

</div>
</div>
<a class="anchor" id="a05a5b23defbab1196cddbee12c1e7f46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to String from Int. </p>

</div>
</div>
<a class="anchor" id="af078b6af10bf0b399622770dd0392cbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromStdString </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given std::basic_string (STL) to the string type used by the royale API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The STL string which should be converted to the royale API vector format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The royale API compliant string format </dd></dl>

</div>
</div>
<a class="anchor" id="a8ab781ffb10caede90dd9a495040f63c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromUInt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to String from unsigned Int. </p>

</div>
</div>
<a class="anchor" id="a8cb106ac4582f9b2714401e6d5faf070"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the string. </p>
<p>Calling this function on an empty string will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the first element in the string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the string is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b29e24293dbe4132c8ce6f188536d51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a274990baf201866f1e4840c7abe3104a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename... Dummy, typename IteratorType , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;IteratorType, reverse_iterator&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::indexFromIterator </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index position the given iterator is pointing to One may receive weird results by passing an iterator of another vector object! Take care that only indices from the current vector object are passed! </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The index position </dd></dl>

</div>
</div>
<a class="anchor" id="a12795ad1f341d42da6833c4b9bc9a22f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename... Dummy, typename IteratorType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;IteratorType, reverse_iterator&gt;::value || royale::iterator::is_same&lt;IteratorType, const_reverse_iterator&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::indexFromIterator </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af11f7ca0dd18490a72dc59ddf8235281"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;IteratorType, iterator&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::indexFromIterator </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index position the given iterator is pointing to One may receive weird results by passing an iterator of another vector object! Take care that only indices from the current vector object are passed! </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The index position </dd></dl>

</div>
</div>
<a class="anchor" id="a6793a07e15fffc1aca8467b6a01f247c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;IteratorType, iterator&gt;::value || royale::iterator::is_same&lt;IteratorType, const_iterator&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::indexFromIterator </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0b35bd43d108b5aa853698f8d742857"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename StringType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements to the string The content at the given position is moved backwards in the string to create space for the elements which shall be inserted - given there is enough allocated space If the allocation is too small to insert the bunch of data, a new block is allocated, while the old data is MOVED (std::move) to the new buffer as long as the insert position is not reached. </p>
<p>When the input position is reached, the input values are completely copied. At the end the original data, after the input position is moved to the new buffer and the internal data buffer is swapped with the created buffer. </p>

</div>
</div>
<a class="anchor" id="a0ec7a387953c396bbb68e0d3d3321db2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename StringType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6cd390895725401e2df6cf617a5db52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a15fbf2166269477080c586b46ac37ef7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a199dbb2f9b29128a9fec0f8743b69b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf6ef29effecff12fa2d15e64852471d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12f316d2c7478359ad24884fffcfa003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5566cecaae5553eed10f52abd86c8d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5df3e319b9e673d784b2c6a99708b29f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;&amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a56354339ca3e21a552747948e7e1cede"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd0ff03060a9a2739bff8e1881e49cf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;&amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; typename <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a8faf6a582542b8cdc384b0eee904679e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f7de3a704276aa4929205ce5bc944a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::iteratorFromIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an forward iterator for the given index. </p>

</div>
</div>
<a class="anchor" id="a783d41ec1e99ea73bd3458cddc5ba962"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::iteratorFromIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af809776b19cba7a749809095208e0aeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual size/length of the string (this is the used amount of slots in the allocated area) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of the actual used memory slots within the string </dd></dl>

</div>
</div>
<a class="anchor" id="a83eb98ed08a7881fc13df7bc3cb0590b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max_size of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The maximum length of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a4c155f20985f6a8c371c81862c559b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with an STL compliant string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An STL compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a1f12322ce9719d9f8f6cd5d148bbc1e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with a royale compliant string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An royale compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a20b558cbb9058a238d0985e38c8b6365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with a C-Style string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A C-style compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a6db1a86f363b6c6b9267352a9638e192"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two stirngs and returns the result (the second string is appended) The content of str is copied to the newly created element (NOTE: a deep copy is performed!). </p>
<p>This effectively increases the container size, which causes an automatic reallocation of the allocated storage space if -and only if- the new string size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a8526b68e24a8c7bc514288ef20030441"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b0bc4697cf123ff2c93ab3ae368e31c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40315b22baee696456acf7baa75643a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f5adfabbcfaa4dc8f33ece4bb424287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the end of the string, after its current last element and returns the actual string element. </p>
<p>The content of str is copied to the new element (NOTE: a deep copy is performed!). This effectively increases the container size, which causes an automatic reallocation of the allocated storage space if -and only if- the new string size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a51c6d96f0b1ad3a1c28ab61ce6f52919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a76856ac5023d9a1d437607a74034ff00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ff8a7c5d2a0cfc6434221b818c5fd01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ad289129843a85f6da3a25921fe479f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks less-than relation with a royale compliant string. </p>
<p>A comparison lhs &lt; rhs will be true if (and only if):</p>
<ul>
<li>lhs is empty, and rhs is not</li>
<li>lhs is a prefix of rhs and shorter than rhs</li>
<li>lhs is not a prefix, and the first differing character in lhs is less than the one in rhs (using the operator&lt; defined by the underlying character type T)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A royale compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if less-than and false if not </dd></dl>

</div>
</div>
<a class="anchor" id="afc01fd5b4ae4c87d37b71ba0976d90da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign another royale compliant string. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. This method copies all elements held by str into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a83b3431347eae688334fd7855d49382f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move elements to another royale compliant string. </p>
<p>Moves the elements of str into the container. The source container is reset to it's initial state which causes the allocation size to be reset (the allocated memory is moved) and the size counter to be reset. The data pointer is set to null.</p>
<p>Leaves the source object in a valid/initial state allowing somebody to reuse it for other purposes/data - like after executing <a class="el" href="classroyale_1_1basic_string.html#a326406f8b4f3c430150441c8f1152377" title="Removes all elements from the string (which are destroyed), leaving the container with a size of 0...">clear()</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="ac5faa84d758be2c15f49c3e6997dec6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the contents of an STL compliant string container by replacing container's current contents if necessary and modifying its size accordingly. </p>
<p>This method copies all elements held by str into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An STL compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a9f06c964b23013a298137907e97bcf1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the contents of an C-Style compliant string container by replacing container's current contents if necessary and modifying its size accordingly. </p>
<p>This method copies all elements held by str into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An C-Style compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a80b9d69ca31d55f25190faf2154f7677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a character to a royale compliant string container by replacing container's current contents and modifying its size accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The character to assign to the royale compliant string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a7cc5379d5781fdcac8bcc499e4fe7773"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with an STL compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An STL compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a7ceff1b415565de95e42174eb9ca1f79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with a royale compliant string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An royale compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a058d0e17bca7e293ebb7a9ece4d66b1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with a C-Style string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An C-Style string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a7695f287c0aee6474e3366f7f6f389f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element. </p>
<p>Returns a reference to the element at position index in the string container. A similar member function, <a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680" title="Access an element.">at()</a>, has the same behavior as this operator function, except that <a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680" title="Access an element.">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the string's storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the string </dd></dl>

</div>
</div>
<a class="anchor" id="aed81540a238ab1c8a56530f25b71f2c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element. </p>
<p>Returns a reference to the element at position index in the string container. A similar member function, <a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680" title="Access an element.">at()</a>, has the same behavior as this operator function, except that <a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680" title="Access an element.">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the string's storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the string </dd></dl>

</div>
</div>
<a class="anchor" id="aa93b4a2fe21f91028344afeb6a0ac568"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last element in the string, effectively reducing the container size by one. </p>
<p>The last element is destroyed by calling it's destructor; the size is reduced by one BUT there is no reallocation performed to resize the string to it's contents or to reduce the the string capacity by one. The allocated space remains the same. </p>

</div>
</div>
<a class="anchor" id="aff17794f88e1107b3a2e89e2bf0afde6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the end of the string, after its current last element. </p>
<p>The content of str is copied to the new element (NOTE: a deep copy is performed!). This effectively increases the container size, which causes an automatic reallocation of the allocated storage space if -and only if- the new string size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a7033616dddc037749c3cb6a8935fc88d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3009df262d03ec25bb308501c65f824"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50ed47847028e76ad19810cbe8dcfe2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="addc2dca452a65908b63266f21f4b29de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c18d78393183efce70780049078379a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b5ed99a88bf1c232068b4dc8ae6d413"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ace3a81a50aa0d0f3055caf3bc2d6de93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4549c6bd0e0ab7d02e2271e577dd9c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ae98bf79c04dc2a790a5e36373e045121">reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse begin (last position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator to the reverse begin of the string </dd></dl>

</div>
</div>
<a class="anchor" id="ab932d087ac23672cbe3b1af26d2aff6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7cc608d2df35aa5cddde9f37d2e3090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes elements Removes from the string either a single element (position) or a range of elements ([first,last)). </p>
<p>This effectively reduces the container size by the number of elements removed, which NOT removed.</p>
<p>The removed elements remain in the string and the allocation size is not changed, the elements are only moved to the end and represent free memory space, the size of the vector is reduced. The destructor is not called for the removed elements! (difference to <a class="el" href="classroyale_1_1basic_string.html#ad96eb8af14b243dfb01bacc218fa4120" title="Erase elements Erases from the string either a single element (position) or a range of elements ([fir...">erase()</a>)</p>
<p>Because strings use an array as their underlying storage, erasing elements in positions other than the string end causes the container to relocate all the elements after the segment erased to their new positions. This is generally an inefficient operation compared to the one performed for the same operation by other kinds of sequence containers (such as list or forward_list).</p>
<p>See <a class="el" href="classroyale_1_1basic_string.html#ad96eb8af14b243dfb01bacc218fa4120" title="Erase elements Erases from the string either a single element (position) or a range of elements ([fir...">erase()</a> to destruct the elements in the range. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator The iterator position to the first element after the deleted range </dd></dl>

</div>
</div>
<a class="anchor" id="a88831af018636507e5ecda364afa7efa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code><a class="el" href="classroyale_1_1basic_string.html#a3441c25480c3727315bda167a6bd6e55">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7b00e492ddfdcfc113015fc2b9e5c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5357e6b130c3675d3d1918a5277c8521"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ae98bf79c04dc2a790a5e36373e045121">reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse end (first position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator to the reverse end of the string </dd></dl>

</div>
</div>
<a class="anchor" id="addf4748d31fecad8a6abf93cdbc83f99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3278d52143eae5d0da08424b29e86ef6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing the elements from "start" to "end" with the element given in the range from "first" to "last". </p>
<p>It only replaces as much items (starting at first) as forseen by the range from "start" to "end". If the number of elements given by "first" and "last" exceeds the range from "start" to "end" the exceeding elements are "dropped" and not used for replacement. Given that the caller wants all elements from "first" to "last" to be replaced/appended there are other signatures of <a class="el" href="classroyale_1_1basic_string.html#a3278d52143eae5d0da08424b29e86ef6" title="Replace elements in a vector This method allows replacing the elements from &quot;start&quot; to &quot;end&quot; with the...">replace()</a> to provide that</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting iterator where the replacement shall start </td></tr>
    <tr><td class="paramname">end</td><td>The end iterator of replacement (this "hard end" will NOT be exceeded) </td></tr>
    <tr><td class="paramname">first</td><td>The iterator to the first element taken for replacement </td></tr>
    <tr><td class="paramname">last</td><td>The iterator to the last element taken for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="afe100f515e26490931630620077bd392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing vector elements with element given in the range from "first" to "last". </p>
<p>It only replaces as much items as forseen by the range from "first" to "last". If the number of elements given by "first" and "last" exceeds the allocation size a reallocation will take place and the elements are appended to the vector. Given that the caller only wants a range of elements to be replaced, even if the the input range might be greater he/she shall use the signature of <a class="el" href="classroyale_1_1basic_string.html#a3278d52143eae5d0da08424b29e86ef6" title="Replace elements in a vector This method allows replacing the elements from &quot;start&quot; to &quot;end&quot; with the...">replace()</a> which provides four iterators as input and accepts an input range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The iterator where the replacement shall start </td></tr>
    <tr><td class="paramname">first</td><td>The iterator to the first element taken for replacement </td></tr>
    <tr><td class="paramname">last</td><td>The iterator to the last element taken for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="aab772f3d7c52813c01d31ea07115b072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename ContainerType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if &lt; !std::is_convertible&lt;ContainerType, T&gt;::value &amp;&amp; !royale::iterator::is_iterator&lt;ContainerType&gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing vector elements with the elements of another input container. </p>
<p>It only replaces as much items, as there are in the input vector. If the number of elements in the input vector exceeds the allocation size a reallocation will take place and the elements are appended to the object. Given that the caller only wants a range of elements to be replaced, even if the the input range might be greater he/she shall use the signature of <a class="el" href="classroyale_1_1basic_string.html#a3278d52143eae5d0da08424b29e86ef6" title="Replace elements in a vector This method allows replacing the elements from &quot;start&quot; to &quot;end&quot; with the...">replace()</a> which provides four iterators as input and accepts an input range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The starting iterator where the replacement shall start </td></tr>
    <tr><td class="paramname">v</td><td>The container which shall be used for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="ace8a29bb5e90dd9d7d17becec5064cb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_start , typename InputIterator_end , typename ContainerType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_start&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_end&gt;::value&gt;::type, typename  = typename std::enable_if &lt; !std::is_convertible&lt;ContainerType, T&gt;::value &amp;&amp; !royale::iterator::is_iterator&lt;ContainerType&gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_start&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_end&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing the elements from "start" to "end" with the elements in the input container. </p>
<p>It only replaces as much items (starting at first) as forseen by the range from "start" to "end". If the number of elements given by "first" and "last" exceeds the range from "start" to "end" the exceeding elements are "dropped" and not used for replacement. Given that the caller wants all elements from "first" to "last" to be replaced/appended there are other signatures of <a class="el" href="classroyale_1_1basic_string.html#a3278d52143eae5d0da08424b29e86ef6" title="Replace elements in a vector This method allows replacing the elements from &quot;start&quot; to &quot;end&quot; with the...">replace()</a> to provide that</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting iterator where the replacement shall start </td></tr>
    <tr><td class="paramname">end</td><td>The end iterator of replacement (this "hard end" will NOT be exceeded) </td></tr>
    <tr><td class="paramname">v</td><td>The container which shall be used for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="a11095afca67c0cc02d09dc88b5020d24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerType , typename  = typename std::enable_if &lt; !std::is_convertible&lt;ContainerType, T&gt;::value &amp;&amp; !royale::iterator::is_iterator&lt;ContainerType&gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing the elements beginning at index with all items held by the container v. </p>
<p>If the number of elements exceeds the allocation size of the vector a reallocation is performanced and the items are moved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index position where the replacement shall be started </td></tr>
    <tr><td class="paramname">v</td><td>The container which shall be used for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="a6469076873a7f9af366f758eb5ca86da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing the elements starting at index with the given range from "first" to "last". </p>
<p>It only replaces as much items (starting at first) as forseen by the range from "first" to "last". If the number of elements given by "first" and "last" exceeds the allocation size a reallocation is performed and the elements are moved to the new allocation space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index position where the replacement shall be started </td></tr>
    <tr><td class="paramname">first</td><td>The iterator to the first element taken for replacement </td></tr>
    <tr><td class="paramname">last</td><td>The iterator to the last element taken for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="aec3d39bc7c6043436b48e252dddf08b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html#ab114ad5253c9066fb12a30b68a2bc132">const_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a69dfa629042c710a532991112d089ca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_start , typename InputIterator_end , typename ContainerType , typename , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_start&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_end&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1ef927fed9e5711461c16e9a954c6c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af68bd65e38f23c0f11af5640fe326e44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename ContainerType , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d678634950c39662c1b65f8e5358857"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aee7b0eac50204e4ab0e067b48be66752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt;::<a class="el" href="classroyale_1_1basic_string.html#a23f69382a3f5949725fa552b58ae29ef">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c953106f528c47f9f3e80d201a7f79d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the string to a higher allocation size and allocates the buffers. </p>
<p>Reserves any amount of free allocation slots (allocates the memory already) to be later used for the element-types bound to the given string vector.</p>
<p>If the given size to reserve is smaller than the already reserved space, then the function return immediately; otherwise the necessary memory allocation is performed and the size is extended to "size"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size (number of element-types) of elements that should be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9de316077ddd24a4cad3df61d155438b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the string to the given allocation size and allocates the buffers (it may shrink) </p>
<p>Creates any amount of elements (allocates the memory already) and moves the existing elements to these slots; afterwards the old space is dumped.</p>
<p>If the given newSize is smaller than the already used slots, the string will shrink. This means that all elements which are not covered within this capacity (the last ones) will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The amount of slots to remain in the string (might shrink or enlarge the string) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e3e9dcf9a252536d0cce17ee9b2cf80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ae98bf79c04dc2a790a5e36373e045121">reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::reverseIteratorFromIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an reverse iterator for the given index. </p>

</div>
</div>
<a class="anchor" id="a61d427ddd26eab3994d16e61fb6f5636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a1b97b056944f5e5c0a37c54947308c78">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::reverseIteratorFromIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6552e9b0cbbf0be9a2594ee2a7afc7fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the string's allocation to it's size. </p>
<p>Changes the size of the allocated buffer to the string's size this may result in freeing unneeded memory allocation. </p>

</div>
</div>
<a class="anchor" id="ad48df31da4d8c5f4b82cb62113834dc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual size/length of the string (this is the used amount of slots in the allocated area) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of the actual used memory slots within the string </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4e880d246daaf8dbb1e8179ca61bd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a substring. </p>

</div>
</div>
<a class="anchor" id="a0eaa2ccdcfac29271a5d35110ff2fad9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows a data swap (convenience function to call classswap) Swaps the given string data with the current one. </p>

</div>
</div>
<a class="anchor" id="ad8a9bacf8fdf1c7bb9a6aa7aa1efc229"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::toStdString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::basic_string which might be used outside the library by the application for further processing. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string containing the items of the </dd></dl>

</div>
</div>
<a class="anchor" id="aea9e942a9588aa0e7e734e106ce30383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::toStdString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::basic_string which might be used if the royale compliant string is a const. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string containing the items of the </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a9e83f590b905885332f9979ba866512c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void classswap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a454da36bff6bdbad033ccb9da2cc400e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac7e49999c31e34b4c5e29b7e6dd1b775"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::EOS = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The NUL terminator, which is '\0' for T = char, and L'\0' for T = wchar_t. </p>

</div>
</div>
<a class="anchor" id="a3441c25480c3727315bda167a6bd6e55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::npos = ( (size_t) ~0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_string_8hpp_source.html">String.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 29 2018 09:46:49 for Royale by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
